import Anthropic from '@anthropic-ai/sdk';
import fs from 'fs-extra';
import path from 'path';
import slugify from 'slugify';

interface JobConfig {
  prompts: string[];
  outputDir: string;
  onProgress?: (current: number, total: number, status: string) => void;
  onComplete?: (results: JobResult[]) => void;
}

interface JobResult {
  prompt: string;
  response: string;
  filename: string;
  success: boolean;
  error?: string;
}

export class ClaudeWorker {
  private client: Anthropic | null = null;
  private apiKey: string;
  private isDemoMode: boolean;

  constructor() {
    this.apiKey = process.env.CLAUDE_API_KEY || process.env.CLAUDE_COOKIE || '';
    this.isDemoMode = !this.apiKey || this.apiKey === 'demo_mode';
    
    if (this.isDemoMode) {
      console.log('üé≠ DEMO mode enabled (no Claude API key provided)');
    } else {
      console.log('üîë Claude API mode enabled');
    }
  }

  async init(): Promise<void> {
    console.log('üöÄ Initializing Claude worker...');
    
    if (this.isDemoMode) {
      console.log('üé≠ DEMO mode: simulating responses');
      return;
    }

    try {
      this.client = new Anthropic({
        apiKey: this.apiKey,
      });
      
      // Test rapide de la cl√© API
      console.log('üß™ Testing Claude API connection...');
      await this.client.messages.create({
        model: 'claude-3-5-sonnet-20241022',
        max_tokens: 10,
        messages: [{ role: 'user', content: 'Test' }],
      });
      
      console.log('‚úÖ Claude worker initialized successfully');
    } catch (error) {
      console.error('‚ùå Claude API initialization error:', error);
      throw new Error('Unable to connect to Claude API. Check your API key.');
    }
  }

  async runJob(config: JobConfig): Promise<JobResult[]> {
    const results: JobResult[] = [];
    const { prompts, outputDir, onProgress } = config;

    // Assurer que le dossier de sortie existe
    await fs.ensureDir(outputDir);

    console.log(`üìÇ Processing ${prompts.length} prompts...`);

    for (let i = 0; i < prompts.length; i++) {
      const prompt = prompts[i];
      onProgress?.(i + 1, prompts.length, `Processing prompt ${i + 1}/${prompts.length}`);

      try {
        const result = this.isDemoMode 
          ? await this.processDemoPrompt(prompt, outputDir, i + 1, prompts.length)
          : await this.processPrompt(prompt, outputDir);
        
        results.push(result);
        console.log(`‚úÖ Prompt ${i + 1}/${prompts.length} processed successfully`);
      } catch (error) {
        const errorResult: JobResult = {
          prompt,
          response: '',
          filename: '',
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error',
        };
        results.push(errorResult);
        console.error(`‚ùå Error processing prompt ${i + 1}:`, error);
      }

      // Pause entre les requ√™tes pour √©viter le rate limiting
      if (i < prompts.length - 1) {
        await this.delay(1000);
      }
    }

    config.onComplete?.(results);
    return results;
  }

  private async processDemoPrompt(prompt: string, outputDir: string, current: number, total: number): Promise<JobResult> {
    // Simulation d'une vraie requ√™te API avec d√©lais r√©alistes
    await this.delay(800); // Simulation temps r√©seau
    
    // Simulation "Claude qui r√©fl√©chit et g√©n√®re"
    await this.delay(2500);
    
    // G√©nerer une r√©ponse DEMO r√©aliste
    const demoResponse = `# Generated Documentation (DEMO Mode)

## Processed Prompt
${prompt}

## Response simulated by Claude Doc Bot

This is a demonstration response. In real mode, this documentation would be generated by Claude 3.5 Sonnet via Anthropic's official API.

### Demonstrated Features:
- ‚úÖ Complete user interface
- ‚úÖ Real-time progress via WebSocket
- ‚úÖ Live log streaming
- ‚úÖ File generation and saving
- ‚úÖ Instant downloads

### Technical Architecture:
- **Claude API**: Replaced Playwright with official API
- **Faster**: ~3 seconds per prompt vs 30+ with Playwright  
- **More reliable**: No dependency on web interface
- **More scalable**: API rate limits handled automatically

### To enable real mode:
1. Add your Claude API key in .env:
   \`\`\`
   CLAUDE_API_KEY=sk-ant-api03-your-key-here
   \`\`\`
2. Restart the application
3. Enjoy ultra-fast automation! ‚ö°

---
*Generated on ${new Date().toLocaleString('en-US')} - Prompt ${current}/${total}*
*In real mode, this content would be produced by Claude 3.5 Sonnet*`;

    // G√©n√©rer le nom de fichier en anglais
    const slug = slugify(`demo-${current}-${prompt.substring(0, 30)}`, { lower: true, strict: true });
    const filename = `${slug}.md`;
    const filepath = path.join(outputDir, filename);

    // Sauvegarder le fichier demo
    await fs.writeFile(filepath, demoResponse, 'utf-8');

    return {
      prompt,
      response: demoResponse,
      filename,
      success: true,
    };
  }

  private async processPrompt(prompt: string, outputDir: string): Promise<JobResult> {
    if (!this.client) throw new Error('Claude client not initialized');

    try {
      console.log('ü§ñ Sending prompt to Claude via API...');
      
      const message = await this.client.messages.create({
        model: 'claude-3-5-sonnet-20241022',
        max_tokens: 4000,
        temperature: 0.7,
        messages: [
          {
            role: 'user',
            content: `You are a technical documentation expert. Here is the prompt to process:

${prompt}

Generate complete, well-structured and professional documentation in Markdown format. Be precise, detailed and include practical examples when relevant.`
          }
        ],
      });

      const response = message.content[0].type === 'text' ? message.content[0].text : '';

      if (!response.trim()) {
        throw new Error('No response received from Claude API');
      }

      // G√©n√©rer le nom de fichier √† partir du prompt
      const slug = slugify(prompt.substring(0, 50), { lower: true, strict: true });
      const filename = `${slug}.md`;
      const filepath = path.join(outputDir, filename);

      // Sauvegarder la r√©ponse avec un en-t√™te
      const content = `# Prompt
${prompt}

# Documentation generated by Claude

${response}

---
*Generated on ${new Date().toLocaleString('en-US')} by Claude 3.5 Sonnet via API*`;

      await fs.writeFile(filepath, content, 'utf-8');

      return {
        prompt,
        response,
        filename,
        success: true,
      };

    } catch (error) {
      console.error('Claude API error:', error);
      throw error;
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async cleanup(): Promise<void> {
    // Plus besoin de nettoyer un navigateur !
    console.log('üßπ Worker cleaned up');
  }
}

// API pour l'utilisation en CLI ou via l'API
export async function runClaudeJob(promptFiles: string[], outputDir: string = './outputs'): Promise<JobResult[]> {
  const worker = new ClaudeWorker();
  
  try {
    await worker.init();
    
    // Charger les prompts depuis les fichiers
    const prompts: string[] = [];
    for (const file of promptFiles) {
      const content = await fs.readFile(file, 'utf-8');
      prompts.push(content.trim());
    }

    const results = await worker.runJob({
      prompts,
      outputDir,
      onProgress: (current, total, status) => {
        console.log(`[${current}/${total}] ${status}`);
      },
    });

    return results;
  } finally {
    await worker.cleanup();
  }
}

// Point d'entr√©e CLI
if (import.meta.url === `file://${process.argv[1]}`) {
  const promptDir = process.argv[2] || './prompts';
  const outputDir = process.argv[3] || './outputs';

  (async () => {
    try {
      // Lister tous les fichiers .txt dans le dossier prompts
      const files = await fs.readdir(promptDir);
      const promptFiles = files
        .filter(f => f.endsWith('.txt'))
        .map(f => path.join(promptDir, f));

      if (promptFiles.length === 0) {
        console.error('‚ùå Aucun fichier .txt trouv√© dans', promptDir);
        process.exit(1);
      }

      console.log(`üéØ ${promptFiles.length} fichiers de prompts trouv√©s`);
      const results = await runClaudeJob(promptFiles, outputDir);
      
      const successful = results.filter(r => r.success).length;
      console.log(`‚ú® Job termin√©: ${successful}/${results.length} prompts trait√©s avec succ√®s`);
      
      if (successful < results.length) {
        process.exit(1);
      }
    } catch (error) {
      console.error('üí• Erreur fatale:', error);
      process.exit(1);
    }
  })();
} 